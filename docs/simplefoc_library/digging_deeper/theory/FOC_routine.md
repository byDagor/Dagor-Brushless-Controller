---
layout: default
title: Field Oriented Control 
parent: Theory corner
grand_parent: Digging deeper
grand_grand_parent: Arduino <span class="simple">Simple<span class="foc">FOC</span>library</span>
description: "Arduino Simple Field Oriented Control (FOC) library ."
nav_order: 1
permalink: /foc_theory
---

# Field Oriented Control algorithm briefly

Field oriented control algorithm's main task is to take user defined voltage <i>u<sub>q</sub></i> and, by continuously reading the position of the motor rotor <i>a</i>, calculate the appropriate phase voltages <i>u<sub>a</sub></i>,<i>u<sub>b</sub></i> and <i>u<sub>c</sub></i>. 

<img src="../extras/Images/voltage_loop.png">

FOC algorithm calculates the phase voltages which create the magnetic field in the motor's rotor which are exactly 90 degrees "behind" the magnetic field of the permanent magnets of the rotor, creating a pushing effect. Here is a very nice animation of what happens inside of the motor when running simplified version of the the FOC called six-step modulation. 

<iframe src='https://gfycat.com/ifr/MealyDeafeningHarpyeagle' frameborder='0' scrolling='no' allowfullscreen width='640' height='404'></iframe><p> <a href="https://gfycat.com/mealydeafeningharpyeagle">via Gfycat</a></p>

Another way to look at why we need 90 degree angle in between rotor and stator fields if by remembering the equation of the electric force generated by the wire passing through the magnetic field:

```cpp
F = B*I*L*sin(alpha)
```

Where `B` is the strength of the magnetic field, `L` is the length of the wire,  `I` is the electric current magnitude and the `alpha` is the angle in between magnetic field `B` and current `I`. From this equation we can see that in order to have the maximum force `F = B*I*L` we need to maintain `alpha` angle equal to 90 degrees or `PI/2` radians.


## How to calculate the appropriate voltages <i>u<sub>a</sub></i>,<i>u<sub>b</sub></i> and <i>u<sub>c</sub></i> 

Since the <span class="simple">Simple<span class="foc">FOC</span>library</span> is intended for education about the FOC algorithm as well for enabling various applications, the two most standard versions of the FOC modulation are implemented in this library. 

- Sinusoidal PWM: `SinePWM`
- Space Vector PWM: `SpaceVectorPWM`

You can configure them by setting the value of `motor.foc_modulation` variable:
```cpp
motor.foc_modulation = FOCModulationType::SinePWM; // default
// or
motor.foc_modulation = FOCModulationType::SpaceVectorPWM;
```


### Sinusoidal modulation `SinePWM`

Sinusoidal modulation is based on two transformation equations.

<img src="../extras/Images/foc_modulation.png" >

Inverse Park transformation:<br>
<img src="../extras/Images/inverse_park.png" style="margin-left:50px;margin-top:10px;margin-bottom:10px;width:150px"><br>
Inverse Clarke transformation:<br>
<img src="../extras/Images/inverse_clarke.png" style="margin-left:50px;margin-top:10px;margin-bottom:10px;width:180px">


Here is the code of implementation of the Sinusoidal PWM in the <span class="simple">Simple<span class="foc">FOC</span>library</span>:
```cpp
// Method using FOC to set Uq to the motor at the optimal angle
void BLDCMotor::setPhaseVoltage(float Uq, float angle_el) {
    // Sinusoidal PWM modulation 
    // Inverse Park + Clarke transformation

    // angle normalization in between 0 and 2pi
    // only necessary if using _sin and _cos - approximation functions
    angle_el = normalizeAngle(angle_el + zero_electric_angle);
    // Inverse park transform
    Ualpha =  -_sin(angle_el) * Uq;  // -sin(angle) * Uq;
    Ubeta =  _cos(angle_el) * Uq;    //  cos(angle) * Uq;

    // Inverse Clarke transform
    Ua = Ualpha + voltage_power_supply/2;
    Ub = -0.5 * Ualpha  + _SQRT3_2 * Ubeta + voltage_power_supply/2;
    Uc = -0.5 * Ualpha - _SQRT3_2 * Ubeta + voltage_power_supply/2;

    // set the voltages in hardware
    setPwm(Ua, Ub, Uc);
}
```

### Space vector modulation `SpaceVectorPWM`

Space Vector modulation is based on two steps of calculations:

<img src="../extras/Images/foc_modulation_svm.png" >

In the first step we find the sector <i>s</i> the rotor is currently in. The angle of 360 degrees is divided into 6 equal parts of 60 degrees. So this calculation is very straight forward. Then we calculate the times <i>T<sub>0</sub></i>, <i>T<sub>1</sub></i> and <i>T<sub>2</sub></i>. <i>T<sub>1</sub></i> and <i>T<sub>2</sub></i>  tell us how long should phase 1 and phase 2 be on and <i>T<sub>0</sub></i> tells us how long should we have 0 voltage on the motor.

<img src="../extras/Images/svm_1.png" style="margin-left:50px;margin-top:10px;margin-bottom:10px;width:250px"><br>


Second step is projecting the <i>T<sub>0,1,2</sub></i> values to the appropriate duty-cycles <i>T<sub>a,b,c</sub></i> which depend directly of the sector the motor is currently in.

Sector | <i>T<sub>a</sub></i> | <i>T<sub>b</sub></i> | <i>T<sub>c</sub></i>
--- | --- | --- | ---
1| <i>T<sub>1</sub></i> + <i>T<sub>2</sub></i> + <i>T<sub>0</sub></i>/2 | <i>T<sub>2</sub></i> + <i>T<sub>0</sub></i>/2 | <i>T<sub>0</sub></i>/2
2| <i>T<sub>1</sub></i> +  <i>T<sub>0</sub></i>/2|<i>T<sub>1</sub></i> + <i>T<sub>2</sub></i> + <i>T<sub>0</sub></i>/2 | <i>T<sub>0</sub></i>/2
3| <i>T<sub>0</sub></i>/2|  <i>T<sub>1</sub></i> + <i>T<sub>2</sub></i> + <i>T<sub>0</sub></i>/2| <i>T<sub>2</sub></i> + <i>T<sub>0</sub></i>/2
4| <i>T<sub>0</sub></i>/2|  <i>T<sub>1</sub></i>+ <i>T<sub>0</sub></i>/2| <i>T<sub>1</sub></i> + <i>T<sub>2</sub></i> + <i>T<sub>0</sub></i>/2
5| <i>T<sub>2</sub></i> + <i>T<sub>0</sub></i>/2|<i>T<sub>0</sub></i>/2 | <i>T<sub>1</sub></i> + <i>T<sub>2</sub></i> + <i>T<sub>0</sub></i>/2
6| <i>T<sub>1</sub></i> + <i>T<sub>2</sub></i> + <i>T<sub>0</sub></i>/2| <i>T<sub>0</sub></i>/2| <i>T<sub>1</sub></i> + <i>T<sub>0</sub></i>/2

Here is one example of a pwm signal generated using SVM table for parameters: <i>s = 2</i>, <i><i>T<sub>1</sub></i> = 1/8 = 0.125</i>, <i><i>T<sub>2</sub></i> = 1/8 = 0.125</i> and <i><i>T<sub>0</sub></i> = 1/2 = 0.5</i>

<img src="../extras/Images/svm_dc.png" >


Here is the code of the Space Vector PWM implementation in the <span class="simple">Simple<span class="foc">FOC</span>library</span>: 
```cpp
// Method using FOC to set Uq to the motor at the optimal angle
void BLDCMotor::setPhaseVoltage(float Uq, float angle_el) {
    // Nice video explaining the SpaceVectorModulation (SVPWM) algorithm 
    // https://www.youtube.com/watch?v=QMSWUMEAejg

    // if negative voltages change inverse the phase 
    // angle + 180degrees
    if(Uq < 0) angle_el += _PI;
    Uq = abs(Uq);

    // angle normalisation in between 0 and 2pi
    // only necessary if using _sin and _cos - approximation functions
    angle_el = normalizeAngle(angle_el + zero_electric_angle + _PI_2);

    // find the sector we are in currently
    int sector = floor(angle_el / _PI_3) + 1;
    // calculate the duty cycles
    float T1 = _SQRT3*_sin(sector*_PI_3 - angle_el) * Uq/voltage_power_supply;
    float T2 = _SQRT3*_sin(angle_el - (sector-1.0)*_PI_3) * Uq/voltage_power_supply;
    // two versions possible 
    // centered around voltage_power_supply/2
    float T0 = 1 - T1 - T2;
    // pulled to 0 - better for low power supply voltage
    //float T0 = 0;

    // calculate the duty cycles(times)
    float Ta,Tb,Tc; 
    switch(sector){
    case 1:
        Ta = T1 + T2 + T0/2;
        Tb = T2 + T0/2;
        Tc = T0/2;
        break;
    case 2:
        Ta = T1 +  T0/2;
        Tb = T1 + T2 + T0/2;
        Tc = T0/2;
        break;
    case 3:
        Ta = T0/2;
        Tb = T1 + T2 + T0/2;
        Tc = T2 + T0/2;
        break;
    case 4:
        Ta = T0/2;
        Tb = T1+ T0/2;
        Tc = T1 + T2 + T0/2;
        break;
    case 5:
        Ta = T2 + T0/2;
        Tb = T0/2;
        Tc = T1 + T2 + T0/2;
        break;
    case 6:
        Ta = T1 + T2 + T0/2;
        Tb = T0/2;
        Tc = T1 + T0/2;
        break;
    default:
        // possible error state
        Ta = 0;
        Tb = 0;
        Tc = 0;
    }

    // calculate the phase voltages
    Ua = Ta*voltage_power_supply;
    Ub = Tb*voltage_power_supply;
    Uc = Tc*voltage_power_supply;

    // set the voltages in hardware
    setPwm(Ua, Ub, Uc);
}
```


## Which one should I use?

Here are images of the waveforms generated by the Sinusoidal and Space Vector modulation for <i>U<sub>q</sub> = 0.5V</i>

Sinusoidal | Space Vector
--- | ---
<img src="../extras/Images/0.5.jpg" class="img400"> | <img src="../extras/Images/svm0.5.jpg"  class="img400">

There are several key differences in between these two algorithms. But in terms of <span class="simple">Simple<span class="foc">FOC</span>library</span> all that you need to know is that Space Vector algorithm better uses the maximal voltage range of the power supply. In the tables above, you can see that for <i>U<sub>q</sub> = 0.5V</i> the magnitude of sine waves generated by the Sinusoidal modulation is exactly equal to 1, and Space vector modulation is not quiet there yet. The "double sine" wave produced by the space vector has lower magnitude by the factor of `2/sqrt(3) = 1.15` which means that it can deliver 15% more power to the motor using same power supply. 

This means, for your power-supply with the voltage <i>V<sub>power_supply</sub></i>, when using `SinePWM` you will be able to set maximal <i>U<sub>q</sub> = 0.5 V<sub>power_supply</sub> </i> and if using `SpaceVectorPWM` you will be able to set <i>U<sub>q</sub> = 0.58 V<sub>power_supply</sub> </i> 
 
The power supply voltage <i>V<sub>power_supply</sub></i> you should specify by changing  the parameter `motor.voltage_power_supply` value. The default value is set to `12V`. If you set your <i>V<sub>power_supply</sub></i> to some other value, change it here for the FOC algorithm will adapt the proper <i>U<sub>q</sub></i> (`motor.voltage_q`) values. 

```cpp
// power supply voltage
motor.voltage_power_supply = 12;
```
<blockquote class="warning"> <p class="heading">What if I don't specify this parameter?</p>
If you don't <code class="highlighter-rouge">motor.voltage_power_supply</code>, the algorithm will still work but your <code class="highlighter-rouge">motor.voltage_q</code> value will no longer be equal to the real output voltage.
</blockquote>
<img src="../extras/Images/sine_foc.png" >


### What happens when I exceed maximal <i>U<sub>q</sub></i>?

If you try to put voltage <i>U<sub>q</sub></i> higher than <i>U<sub>q</sub> = 0.5 V<sub>power_supply</sub> </i>  for `SinePWM` or <i>U<sub>q</sub> = 0.58 V<sub>power_supply</sub> </i>  for `SpaceVectorPWM`, it will still work but the <i>U<sub>a,b,c</sub></i> signals will be saturated.

Here are few images of the `SinePWM` for different <i>U<sub>q</sub></i>  values.

<i>U<sub>q</sub> = 0.5 V<sub>power_supply</sub> </i> | <i>U<sub>q</sub> = 0.6 V<sub>power_supply</sub> </i> | <i>U<sub>q</sub> = V<sub>power_supply</sub> </i>
--- | --- | ---
<img src="../extras/Images/0.5.jpg" class="img200"> | <img src="../extras/Images/0.6.jpg"  class="img200"> | <img src="../extras/Images/1.jpg"  class="img200">

Basically what you can see on images is that the <i>U<sub>a,b,c</sub></i> are saturated and you are actually not setting sinusoidal waves to your motor any more after you surpass the maximal values. 
The motor is still getting some increase of power, but it is no longer linear or smooth. 

<blockquote class="warning"> <p class="heading">RULE OF THUMB</p>
In reality the motor can see the difference all the way till <i>U<sub>q</sub> ~ 0.7 V<sub>power_supply</sub> </i>. After this value the <i>U<sub>a,b,c</sub></i> are too saturated and further increase of <i>U<sub>q</sub></i> doesn't result in increase of motor power.

But every motor is a bit different and you can check these values empirically on your own easily. Just put the motor in the voltage control and see after which value of the voltage <i>U<sub>q</sub></i> you can no longer see the improvement in motor power (it will stop accelerating).
</blockquote>

## Further read

For more info about the initialization procedure, real-time execution and the implementation details please visit [FOC implementation docs](foc_implementation).